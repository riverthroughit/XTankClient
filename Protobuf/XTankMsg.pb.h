// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: XTankMsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_XTankMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_XTankMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_XTankMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_XTankMsg_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_XTankMsg_2eproto;
namespace XTankMsg {
class GameExitAck;
struct GameExitAckDefaultTypeInternal;
extern GameExitAckDefaultTypeInternal _GameExitAck_default_instance_;
class GameExitReq;
struct GameExitReqDefaultTypeInternal;
extern GameExitReqDefaultTypeInternal _GameExitReq_default_instance_;
class GameForwardNtf;
struct GameForwardNtfDefaultTypeInternal;
extern GameForwardNtfDefaultTypeInternal _GameForwardNtf_default_instance_;
class GameInputNtf;
struct GameInputNtfDefaultTypeInternal;
extern GameInputNtfDefaultTypeInternal _GameInputNtf_default_instance_;
class GameReadyAck;
struct GameReadyAckDefaultTypeInternal;
extern GameReadyAckDefaultTypeInternal _GameReadyAck_default_instance_;
class GameReadyCancelAck;
struct GameReadyCancelAckDefaultTypeInternal;
extern GameReadyCancelAckDefaultTypeInternal _GameReadyCancelAck_default_instance_;
class GameReadyCancelReq;
struct GameReadyCancelReqDefaultTypeInternal;
extern GameReadyCancelReqDefaultTypeInternal _GameReadyCancelReq_default_instance_;
class GameReadyNtf;
struct GameReadyNtfDefaultTypeInternal;
extern GameReadyNtfDefaultTypeInternal _GameReadyNtf_default_instance_;
class GameReadyReq;
struct GameReadyReqDefaultTypeInternal;
extern GameReadyReqDefaultTypeInternal _GameReadyReq_default_instance_;
class GameStartNtf;
struct GameStartNtfDefaultTypeInternal;
extern GameStartNtfDefaultTypeInternal _GameStartNtf_default_instance_;
class LobbyNtf;
struct LobbyNtfDefaultTypeInternal;
extern LobbyNtfDefaultTypeInternal _LobbyNtf_default_instance_;
class LobbyNtf_RoomInfo;
struct LobbyNtf_RoomInfoDefaultTypeInternal;
extern LobbyNtf_RoomInfoDefaultTypeInternal _LobbyNtf_RoomInfo_default_instance_;
class LoginAck;
struct LoginAckDefaultTypeInternal;
extern LoginAckDefaultTypeInternal _LoginAck_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LogoutAck;
struct LogoutAckDefaultTypeInternal;
extern LogoutAckDefaultTypeInternal _LogoutAck_default_instance_;
class LogoutReq;
struct LogoutReqDefaultTypeInternal;
extern LogoutReqDefaultTypeInternal _LogoutReq_default_instance_;
class PlayerId;
struct PlayerIdDefaultTypeInternal;
extern PlayerIdDefaultTypeInternal _PlayerId_default_instance_;
class RoomCreateAck;
struct RoomCreateAckDefaultTypeInternal;
extern RoomCreateAckDefaultTypeInternal _RoomCreateAck_default_instance_;
class RoomCreateReq;
struct RoomCreateReqDefaultTypeInternal;
extern RoomCreateReqDefaultTypeInternal _RoomCreateReq_default_instance_;
class RoomExitAck;
struct RoomExitAckDefaultTypeInternal;
extern RoomExitAckDefaultTypeInternal _RoomExitAck_default_instance_;
class RoomExitReq;
struct RoomExitReqDefaultTypeInternal;
extern RoomExitReqDefaultTypeInternal _RoomExitReq_default_instance_;
class RoomJoinAck;
struct RoomJoinAckDefaultTypeInternal;
extern RoomJoinAckDefaultTypeInternal _RoomJoinAck_default_instance_;
class RoomJoinReq;
struct RoomJoinReqDefaultTypeInternal;
extern RoomJoinReqDefaultTypeInternal _RoomJoinReq_default_instance_;
class RoomNtf;
struct RoomNtfDefaultTypeInternal;
extern RoomNtfDefaultTypeInternal _RoomNtf_default_instance_;
class RoomNtf_PlayerState;
struct RoomNtf_PlayerStateDefaultTypeInternal;
extern RoomNtf_PlayerStateDefaultTypeInternal _RoomNtf_PlayerState_default_instance_;
}  // namespace XTankMsg
PROTOBUF_NAMESPACE_OPEN
template<> ::XTankMsg::GameExitAck* Arena::CreateMaybeMessage<::XTankMsg::GameExitAck>(Arena*);
template<> ::XTankMsg::GameExitReq* Arena::CreateMaybeMessage<::XTankMsg::GameExitReq>(Arena*);
template<> ::XTankMsg::GameForwardNtf* Arena::CreateMaybeMessage<::XTankMsg::GameForwardNtf>(Arena*);
template<> ::XTankMsg::GameInputNtf* Arena::CreateMaybeMessage<::XTankMsg::GameInputNtf>(Arena*);
template<> ::XTankMsg::GameReadyAck* Arena::CreateMaybeMessage<::XTankMsg::GameReadyAck>(Arena*);
template<> ::XTankMsg::GameReadyCancelAck* Arena::CreateMaybeMessage<::XTankMsg::GameReadyCancelAck>(Arena*);
template<> ::XTankMsg::GameReadyCancelReq* Arena::CreateMaybeMessage<::XTankMsg::GameReadyCancelReq>(Arena*);
template<> ::XTankMsg::GameReadyNtf* Arena::CreateMaybeMessage<::XTankMsg::GameReadyNtf>(Arena*);
template<> ::XTankMsg::GameReadyReq* Arena::CreateMaybeMessage<::XTankMsg::GameReadyReq>(Arena*);
template<> ::XTankMsg::GameStartNtf* Arena::CreateMaybeMessage<::XTankMsg::GameStartNtf>(Arena*);
template<> ::XTankMsg::LobbyNtf* Arena::CreateMaybeMessage<::XTankMsg::LobbyNtf>(Arena*);
template<> ::XTankMsg::LobbyNtf_RoomInfo* Arena::CreateMaybeMessage<::XTankMsg::LobbyNtf_RoomInfo>(Arena*);
template<> ::XTankMsg::LoginAck* Arena::CreateMaybeMessage<::XTankMsg::LoginAck>(Arena*);
template<> ::XTankMsg::LoginReq* Arena::CreateMaybeMessage<::XTankMsg::LoginReq>(Arena*);
template<> ::XTankMsg::LogoutAck* Arena::CreateMaybeMessage<::XTankMsg::LogoutAck>(Arena*);
template<> ::XTankMsg::LogoutReq* Arena::CreateMaybeMessage<::XTankMsg::LogoutReq>(Arena*);
template<> ::XTankMsg::PlayerId* Arena::CreateMaybeMessage<::XTankMsg::PlayerId>(Arena*);
template<> ::XTankMsg::RoomCreateAck* Arena::CreateMaybeMessage<::XTankMsg::RoomCreateAck>(Arena*);
template<> ::XTankMsg::RoomCreateReq* Arena::CreateMaybeMessage<::XTankMsg::RoomCreateReq>(Arena*);
template<> ::XTankMsg::RoomExitAck* Arena::CreateMaybeMessage<::XTankMsg::RoomExitAck>(Arena*);
template<> ::XTankMsg::RoomExitReq* Arena::CreateMaybeMessage<::XTankMsg::RoomExitReq>(Arena*);
template<> ::XTankMsg::RoomJoinAck* Arena::CreateMaybeMessage<::XTankMsg::RoomJoinAck>(Arena*);
template<> ::XTankMsg::RoomJoinReq* Arena::CreateMaybeMessage<::XTankMsg::RoomJoinReq>(Arena*);
template<> ::XTankMsg::RoomNtf* Arena::CreateMaybeMessage<::XTankMsg::RoomNtf>(Arena*);
template<> ::XTankMsg::RoomNtf_PlayerState* Arena::CreateMaybeMessage<::XTankMsg::RoomNtf_PlayerState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace XTankMsg {

enum MSG : int {
  NONE = 0,
  LOGIN_REQ = 1,
  LOGIN_ACK = 2,
  LOGOUT_REQ = 3,
  LOGOUT_ACK = 4,
  LOBBY_NTF = 5,
  ROOM_CREATE_REQ = 6,
  ROOM_CREATE_ACK = 7,
  ROOM_JOIN_REQ = 8,
  ROOM_JOIN_ACK = 9,
  ROOM_EXIT_REQ = 10,
  ROOM_EXIT_ACK = 11,
  ROOM_NTF = 12,
  GAME_READY_REQ = 13,
  GAME_READY_ACK = 14,
  GAME_READY_CANCEL_REQ = 15,
  GAME_READY_CANCEL_ACK = 16,
  GAME_READY_NTF = 17,
  GAME_START_NTF = 18,
  GAME_INPUT_NTF = 19,
  GAME_FORWARD_NTF = 20,
  GAME_EXIT_REQ = 21,
  GAME_EXIT_ACK = 22,
  MSG_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MSG_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MSG_IsValid(int value);
constexpr MSG MSG_MIN = NONE;
constexpr MSG MSG_MAX = GAME_EXIT_ACK;
constexpr int MSG_ARRAYSIZE = MSG_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MSG_descriptor();
template<typename T>
inline const std::string& MSG_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MSG>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MSG_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MSG_descriptor(), enum_t_value);
}
inline bool MSG_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MSG* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MSG>(
    MSG_descriptor(), name, value);
}
// ===================================================================

class PlayerId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.PlayerId) */ {
 public:
  inline PlayerId() : PlayerId(nullptr) {}
  ~PlayerId() override;
  explicit constexpr PlayerId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerId(const PlayerId& from);
  PlayerId(PlayerId&& from) noexcept
    : PlayerId() {
    *this = ::std::move(from);
  }

  inline PlayerId& operator=(const PlayerId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerId& operator=(PlayerId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerId* internal_default_instance() {
    return reinterpret_cast<const PlayerId*>(
               &_PlayerId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerId& a, PlayerId& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.PlayerId";
  }
  protected:
  explicit PlayerId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // uint64 pid = 2;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.PlayerId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  uint64_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit constexpr LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LoginAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LoginAck) */ {
 public:
  inline LoginAck() : LoginAck(nullptr) {}
  ~LoginAck() override;
  explicit constexpr LoginAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginAck(const LoginAck& from);
  LoginAck(LoginAck&& from) noexcept
    : LoginAck() {
    *this = ::std::move(from);
  }

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAck& operator=(LoginAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginAck* internal_default_instance() {
    return reinterpret_cast<const LoginAck*>(
               &_LoginAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginAck& a, LoginAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LoginAck";
  }
  protected:
  explicit LoginAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.LoginAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LogoutReq) */ {
 public:
  inline LogoutReq() : LogoutReq(nullptr) {}
  ~LogoutReq() override;
  explicit constexpr LogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutReq(const LogoutReq& from);
  LogoutReq(LogoutReq&& from) noexcept
    : LogoutReq() {
    *this = ::std::move(from);
  }

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutReq& operator=(LogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutReq* internal_default_instance() {
    return reinterpret_cast<const LogoutReq*>(
               &_LogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LogoutReq& a, LogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogoutReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LogoutReq";
  }
  protected:
  explicit LogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.LogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LogoutAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LogoutAck) */ {
 public:
  inline LogoutAck() : LogoutAck(nullptr) {}
  ~LogoutAck() override;
  explicit constexpr LogoutAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutAck(const LogoutAck& from);
  LogoutAck(LogoutAck&& from) noexcept
    : LogoutAck() {
    *this = ::std::move(from);
  }

  inline LogoutAck& operator=(const LogoutAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutAck& operator=(LogoutAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutAck* internal_default_instance() {
    return reinterpret_cast<const LogoutAck*>(
               &_LogoutAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogoutAck& a, LogoutAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogoutAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LogoutAck";
  }
  protected:
  explicit LogoutAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.LogoutAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LobbyNtf_RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LobbyNtf.RoomInfo) */ {
 public:
  inline LobbyNtf_RoomInfo() : LobbyNtf_RoomInfo(nullptr) {}
  ~LobbyNtf_RoomInfo() override;
  explicit constexpr LobbyNtf_RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyNtf_RoomInfo(const LobbyNtf_RoomInfo& from);
  LobbyNtf_RoomInfo(LobbyNtf_RoomInfo&& from) noexcept
    : LobbyNtf_RoomInfo() {
    *this = ::std::move(from);
  }

  inline LobbyNtf_RoomInfo& operator=(const LobbyNtf_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyNtf_RoomInfo& operator=(LobbyNtf_RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyNtf_RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyNtf_RoomInfo* internal_default_instance() {
    return reinterpret_cast<const LobbyNtf_RoomInfo*>(
               &_LobbyNtf_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LobbyNtf_RoomInfo& a, LobbyNtf_RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyNtf_RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyNtf_RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyNtf_RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyNtf_RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyNtf_RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyNtf_RoomInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyNtf_RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LobbyNtf.RoomInfo";
  }
  protected:
  explicit LobbyNtf_RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPlayerNumFieldNumber = 2,
    kInGameFieldNumber = 3,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 playerNum = 2;
  void clear_playernum();
  uint32_t playernum() const;
  void set_playernum(uint32_t value);
  private:
  uint32_t _internal_playernum() const;
  void _internal_set_playernum(uint32_t value);
  public:

  // bool inGame = 3;
  void clear_ingame();
  bool ingame() const;
  void set_ingame(bool value);
  private:
  bool _internal_ingame() const;
  void _internal_set_ingame(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.LobbyNtf.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t id_;
  uint32_t playernum_;
  bool ingame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class LobbyNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.LobbyNtf) */ {
 public:
  inline LobbyNtf() : LobbyNtf(nullptr) {}
  ~LobbyNtf() override;
  explicit constexpr LobbyNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyNtf(const LobbyNtf& from);
  LobbyNtf(LobbyNtf&& from) noexcept
    : LobbyNtf() {
    *this = ::std::move(from);
  }

  inline LobbyNtf& operator=(const LobbyNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyNtf& operator=(LobbyNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyNtf* internal_default_instance() {
    return reinterpret_cast<const LobbyNtf*>(
               &_LobbyNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LobbyNtf& a, LobbyNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.LobbyNtf";
  }
  protected:
  explicit LobbyNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LobbyNtf_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .XTankMsg.LobbyNtf.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::XTankMsg::LobbyNtf_RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >*
      mutable_rooms();
  private:
  const ::XTankMsg::LobbyNtf_RoomInfo& _internal_rooms(int index) const;
  ::XTankMsg::LobbyNtf_RoomInfo* _internal_add_rooms();
  public:
  const ::XTankMsg::LobbyNtf_RoomInfo& rooms(int index) const;
  ::XTankMsg::LobbyNtf_RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:XTankMsg.LobbyNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo > rooms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomCreateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomCreateReq) */ {
 public:
  inline RoomCreateReq() : RoomCreateReq(nullptr) {}
  ~RoomCreateReq() override;
  explicit constexpr RoomCreateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomCreateReq(const RoomCreateReq& from);
  RoomCreateReq(RoomCreateReq&& from) noexcept
    : RoomCreateReq() {
    *this = ::std::move(from);
  }

  inline RoomCreateReq& operator=(const RoomCreateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCreateReq& operator=(RoomCreateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomCreateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomCreateReq* internal_default_instance() {
    return reinterpret_cast<const RoomCreateReq*>(
               &_RoomCreateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoomCreateReq& a, RoomCreateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomCreateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomCreateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomCreateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomCreateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomCreateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomCreateReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomCreateReq";
  }
  protected:
  explicit RoomCreateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomCreateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomCreateAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomCreateAck) */ {
 public:
  inline RoomCreateAck() : RoomCreateAck(nullptr) {}
  ~RoomCreateAck() override;
  explicit constexpr RoomCreateAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomCreateAck(const RoomCreateAck& from);
  RoomCreateAck(RoomCreateAck&& from) noexcept
    : RoomCreateAck() {
    *this = ::std::move(from);
  }

  inline RoomCreateAck& operator=(const RoomCreateAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCreateAck& operator=(RoomCreateAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomCreateAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomCreateAck* internal_default_instance() {
    return reinterpret_cast<const RoomCreateAck*>(
               &_RoomCreateAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoomCreateAck& a, RoomCreateAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomCreateAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomCreateAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomCreateAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomCreateAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomCreateAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomCreateAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreateAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomCreateAck";
  }
  protected:
  explicit RoomCreateAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomCreateAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomJoinReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomJoinReq) */ {
 public:
  inline RoomJoinReq() : RoomJoinReq(nullptr) {}
  ~RoomJoinReq() override;
  explicit constexpr RoomJoinReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomJoinReq(const RoomJoinReq& from);
  RoomJoinReq(RoomJoinReq&& from) noexcept
    : RoomJoinReq() {
    *this = ::std::move(from);
  }

  inline RoomJoinReq& operator=(const RoomJoinReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomJoinReq& operator=(RoomJoinReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomJoinReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomJoinReq* internal_default_instance() {
    return reinterpret_cast<const RoomJoinReq*>(
               &_RoomJoinReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoomJoinReq& a, RoomJoinReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomJoinReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomJoinReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomJoinReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomJoinReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomJoinReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomJoinReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomJoinReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomJoinReq";
  }
  protected:
  explicit RoomJoinReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // uint64 roomId = 2;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomJoinReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  uint64_t roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomJoinAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomJoinAck) */ {
 public:
  inline RoomJoinAck() : RoomJoinAck(nullptr) {}
  ~RoomJoinAck() override;
  explicit constexpr RoomJoinAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomJoinAck(const RoomJoinAck& from);
  RoomJoinAck(RoomJoinAck&& from) noexcept
    : RoomJoinAck() {
    *this = ::std::move(from);
  }

  inline RoomJoinAck& operator=(const RoomJoinAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomJoinAck& operator=(RoomJoinAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomJoinAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomJoinAck* internal_default_instance() {
    return reinterpret_cast<const RoomJoinAck*>(
               &_RoomJoinAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RoomJoinAck& a, RoomJoinAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomJoinAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomJoinAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomJoinAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomJoinAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomJoinAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomJoinAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomJoinAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomJoinAck";
  }
  protected:
  explicit RoomJoinAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomJoinAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomExitReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomExitReq) */ {
 public:
  inline RoomExitReq() : RoomExitReq(nullptr) {}
  ~RoomExitReq() override;
  explicit constexpr RoomExitReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomExitReq(const RoomExitReq& from);
  RoomExitReq(RoomExitReq&& from) noexcept
    : RoomExitReq() {
    *this = ::std::move(from);
  }

  inline RoomExitReq& operator=(const RoomExitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomExitReq& operator=(RoomExitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomExitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomExitReq* internal_default_instance() {
    return reinterpret_cast<const RoomExitReq*>(
               &_RoomExitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RoomExitReq& a, RoomExitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomExitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomExitReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomExitReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomExitReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomExitReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomExitReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomExitReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomExitReq";
  }
  protected:
  explicit RoomExitReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomExitReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomExitAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomExitAck) */ {
 public:
  inline RoomExitAck() : RoomExitAck(nullptr) {}
  ~RoomExitAck() override;
  explicit constexpr RoomExitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomExitAck(const RoomExitAck& from);
  RoomExitAck(RoomExitAck&& from) noexcept
    : RoomExitAck() {
    *this = ::std::move(from);
  }

  inline RoomExitAck& operator=(const RoomExitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomExitAck& operator=(RoomExitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomExitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomExitAck* internal_default_instance() {
    return reinterpret_cast<const RoomExitAck*>(
               &_RoomExitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RoomExitAck& a, RoomExitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomExitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomExitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomExitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomExitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomExitAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomExitAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomExitAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomExitAck";
  }
  protected:
  explicit RoomExitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomExitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomNtf_PlayerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomNtf.PlayerState) */ {
 public:
  inline RoomNtf_PlayerState() : RoomNtf_PlayerState(nullptr) {}
  ~RoomNtf_PlayerState() override;
  explicit constexpr RoomNtf_PlayerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomNtf_PlayerState(const RoomNtf_PlayerState& from);
  RoomNtf_PlayerState(RoomNtf_PlayerState&& from) noexcept
    : RoomNtf_PlayerState() {
    *this = ::std::move(from);
  }

  inline RoomNtf_PlayerState& operator=(const RoomNtf_PlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomNtf_PlayerState& operator=(RoomNtf_PlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomNtf_PlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomNtf_PlayerState* internal_default_instance() {
    return reinterpret_cast<const RoomNtf_PlayerState*>(
               &_RoomNtf_PlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RoomNtf_PlayerState& a, RoomNtf_PlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomNtf_PlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomNtf_PlayerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomNtf_PlayerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomNtf_PlayerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomNtf_PlayerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomNtf_PlayerState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomNtf_PlayerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomNtf.PlayerState";
  }
  protected:
  explicit RoomNtf_PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kReadyFieldNumber = 2,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // bool ready = 2;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomNtf.PlayerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  bool ready_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class RoomNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.RoomNtf) */ {
 public:
  inline RoomNtf() : RoomNtf(nullptr) {}
  ~RoomNtf() override;
  explicit constexpr RoomNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomNtf(const RoomNtf& from);
  RoomNtf(RoomNtf&& from) noexcept
    : RoomNtf() {
    *this = ::std::move(from);
  }

  inline RoomNtf& operator=(const RoomNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomNtf& operator=(RoomNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomNtf* internal_default_instance() {
    return reinterpret_cast<const RoomNtf*>(
               &_RoomNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RoomNtf& a, RoomNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.RoomNtf";
  }
  protected:
  explicit RoomNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoomNtf_PlayerState PlayerState;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerStatesFieldNumber = 2,
    kRoomIdFieldNumber = 1,
  };
  // repeated .XTankMsg.RoomNtf.PlayerState playerStates = 2;
  int playerstates_size() const;
  private:
  int _internal_playerstates_size() const;
  public:
  void clear_playerstates();
  ::XTankMsg::RoomNtf_PlayerState* mutable_playerstates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >*
      mutable_playerstates();
  private:
  const ::XTankMsg::RoomNtf_PlayerState& _internal_playerstates(int index) const;
  ::XTankMsg::RoomNtf_PlayerState* _internal_add_playerstates();
  public:
  const ::XTankMsg::RoomNtf_PlayerState& playerstates(int index) const;
  ::XTankMsg::RoomNtf_PlayerState* add_playerstates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >&
      playerstates() const;

  // uint32 roomId = 1;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.RoomNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState > playerstates_;
  uint32_t roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameReadyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameReadyReq) */ {
 public:
  inline GameReadyReq() : GameReadyReq(nullptr) {}
  ~GameReadyReq() override;
  explicit constexpr GameReadyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReadyReq(const GameReadyReq& from);
  GameReadyReq(GameReadyReq&& from) noexcept
    : GameReadyReq() {
    *this = ::std::move(from);
  }

  inline GameReadyReq& operator=(const GameReadyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReadyReq& operator=(GameReadyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReadyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReadyReq* internal_default_instance() {
    return reinterpret_cast<const GameReadyReq*>(
               &_GameReadyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GameReadyReq& a, GameReadyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReadyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReadyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReadyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReadyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReadyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReadyReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReadyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameReadyReq";
  }
  protected:
  explicit GameReadyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.GameReadyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameReadyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameReadyAck) */ {
 public:
  inline GameReadyAck() : GameReadyAck(nullptr) {}
  ~GameReadyAck() override;
  explicit constexpr GameReadyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReadyAck(const GameReadyAck& from);
  GameReadyAck(GameReadyAck&& from) noexcept
    : GameReadyAck() {
    *this = ::std::move(from);
  }

  inline GameReadyAck& operator=(const GameReadyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReadyAck& operator=(GameReadyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReadyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReadyAck* internal_default_instance() {
    return reinterpret_cast<const GameReadyAck*>(
               &_GameReadyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GameReadyAck& a, GameReadyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReadyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReadyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReadyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReadyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReadyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReadyAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReadyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameReadyAck";
  }
  protected:
  explicit GameReadyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameReadyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameReadyCancelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameReadyCancelReq) */ {
 public:
  inline GameReadyCancelReq() : GameReadyCancelReq(nullptr) {}
  ~GameReadyCancelReq() override;
  explicit constexpr GameReadyCancelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReadyCancelReq(const GameReadyCancelReq& from);
  GameReadyCancelReq(GameReadyCancelReq&& from) noexcept
    : GameReadyCancelReq() {
    *this = ::std::move(from);
  }

  inline GameReadyCancelReq& operator=(const GameReadyCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReadyCancelReq& operator=(GameReadyCancelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReadyCancelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReadyCancelReq* internal_default_instance() {
    return reinterpret_cast<const GameReadyCancelReq*>(
               &_GameReadyCancelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GameReadyCancelReq& a, GameReadyCancelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReadyCancelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReadyCancelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReadyCancelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReadyCancelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReadyCancelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReadyCancelReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReadyCancelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameReadyCancelReq";
  }
  protected:
  explicit GameReadyCancelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.GameReadyCancelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameReadyCancelAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameReadyCancelAck) */ {
 public:
  inline GameReadyCancelAck() : GameReadyCancelAck(nullptr) {}
  ~GameReadyCancelAck() override;
  explicit constexpr GameReadyCancelAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReadyCancelAck(const GameReadyCancelAck& from);
  GameReadyCancelAck(GameReadyCancelAck&& from) noexcept
    : GameReadyCancelAck() {
    *this = ::std::move(from);
  }

  inline GameReadyCancelAck& operator=(const GameReadyCancelAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReadyCancelAck& operator=(GameReadyCancelAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReadyCancelAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReadyCancelAck* internal_default_instance() {
    return reinterpret_cast<const GameReadyCancelAck*>(
               &_GameReadyCancelAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GameReadyCancelAck& a, GameReadyCancelAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReadyCancelAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReadyCancelAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReadyCancelAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReadyCancelAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReadyCancelAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReadyCancelAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReadyCancelAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameReadyCancelAck";
  }
  protected:
  explicit GameReadyCancelAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameReadyCancelAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameReadyNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameReadyNtf) */ {
 public:
  inline GameReadyNtf() : GameReadyNtf(nullptr) {}
  ~GameReadyNtf() override;
  explicit constexpr GameReadyNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReadyNtf(const GameReadyNtf& from);
  GameReadyNtf(GameReadyNtf&& from) noexcept
    : GameReadyNtf() {
    *this = ::std::move(from);
  }

  inline GameReadyNtf& operator=(const GameReadyNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReadyNtf& operator=(GameReadyNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReadyNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReadyNtf* internal_default_instance() {
    return reinterpret_cast<const GameReadyNtf*>(
               &_GameReadyNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GameReadyNtf& a, GameReadyNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReadyNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReadyNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReadyNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReadyNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReadyNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReadyNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReadyNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameReadyNtf";
  }
  protected:
  explicit GameReadyNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameReadyNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameStartNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameStartNtf) */ {
 public:
  inline GameStartNtf() : GameStartNtf(nullptr) {}
  ~GameStartNtf() override;
  explicit constexpr GameStartNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStartNtf(const GameStartNtf& from);
  GameStartNtf(GameStartNtf&& from) noexcept
    : GameStartNtf() {
    *this = ::std::move(from);
  }

  inline GameStartNtf& operator=(const GameStartNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStartNtf& operator=(GameStartNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStartNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStartNtf* internal_default_instance() {
    return reinterpret_cast<const GameStartNtf*>(
               &_GameStartNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GameStartNtf& a, GameStartNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStartNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStartNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStartNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStartNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameStartNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameStartNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStartNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameStartNtf";
  }
  protected:
  explicit GameStartNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdsFieldNumber = 2,
    kLatencyFieldNumber = 1,
  };
  // repeated .XTankMsg.PlayerId playerIds = 2;
  int playerids_size() const;
  private:
  int _internal_playerids_size() const;
  public:
  void clear_playerids();
  ::XTankMsg::PlayerId* mutable_playerids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >*
      mutable_playerids();
  private:
  const ::XTankMsg::PlayerId& _internal_playerids(int index) const;
  ::XTankMsg::PlayerId* _internal_add_playerids();
  public:
  const ::XTankMsg::PlayerId& playerids(int index) const;
  ::XTankMsg::PlayerId* add_playerids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >&
      playerids() const;

  // float latency = 1;
  void clear_latency();
  float latency() const;
  void set_latency(float value);
  private:
  float _internal_latency() const;
  void _internal_set_latency(float value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameStartNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId > playerids_;
  float latency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameInputNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameInputNtf) */ {
 public:
  inline GameInputNtf() : GameInputNtf(nullptr) {}
  ~GameInputNtf() override;
  explicit constexpr GameInputNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameInputNtf(const GameInputNtf& from);
  GameInputNtf(GameInputNtf&& from) noexcept
    : GameInputNtf() {
    *this = ::std::move(from);
  }

  inline GameInputNtf& operator=(const GameInputNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameInputNtf& operator=(GameInputNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameInputNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameInputNtf* internal_default_instance() {
    return reinterpret_cast<const GameInputNtf*>(
               &_GameInputNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GameInputNtf& a, GameInputNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(GameInputNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameInputNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameInputNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameInputNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameInputNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameInputNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInputNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameInputNtf";
  }
  protected:
  explicit GameInputNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kFrameIdFieldNumber = 2,
    kPlayerCmdFieldNumber = 3,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // uint32 frameId = 2;
  void clear_frameid();
  uint32_t frameid() const;
  void set_frameid(uint32_t value);
  private:
  uint32_t _internal_frameid() const;
  void _internal_set_frameid(uint32_t value);
  public:

  // uint32 playerCmd = 3;
  void clear_playercmd();
  uint32_t playercmd() const;
  void set_playercmd(uint32_t value);
  private:
  uint32_t _internal_playercmd() const;
  void _internal_set_playercmd(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameInputNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  uint32_t frameid_;
  uint32_t playercmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameForwardNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameForwardNtf) */ {
 public:
  inline GameForwardNtf() : GameForwardNtf(nullptr) {}
  ~GameForwardNtf() override;
  explicit constexpr GameForwardNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameForwardNtf(const GameForwardNtf& from);
  GameForwardNtf(GameForwardNtf&& from) noexcept
    : GameForwardNtf() {
    *this = ::std::move(from);
  }

  inline GameForwardNtf& operator=(const GameForwardNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameForwardNtf& operator=(GameForwardNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameForwardNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameForwardNtf* internal_default_instance() {
    return reinterpret_cast<const GameForwardNtf*>(
               &_GameForwardNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GameForwardNtf& a, GameForwardNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(GameForwardNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameForwardNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameForwardNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameForwardNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameForwardNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameForwardNtf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameForwardNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameForwardNtf";
  }
  protected:
  explicit GameForwardNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerCmdsFieldNumber = 2,
    kFrameIdFieldNumber = 1,
  };
  // repeated uint32 playerCmds = 2;
  int playercmds_size() const;
  private:
  int _internal_playercmds_size() const;
  public:
  void clear_playercmds();
  private:
  uint32_t _internal_playercmds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_playercmds() const;
  void _internal_add_playercmds(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_playercmds();
  public:
  uint32_t playercmds(int index) const;
  void set_playercmds(int index, uint32_t value);
  void add_playercmds(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      playercmds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_playercmds();

  // uint32 frameId = 1;
  void clear_frameid();
  uint32_t frameid() const;
  void set_frameid(uint32_t value);
  private:
  uint32_t _internal_frameid() const;
  void _internal_set_frameid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameForwardNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > playercmds_;
  mutable std::atomic<int> _playercmds_cached_byte_size_;
  uint32_t frameid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameExitReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameExitReq) */ {
 public:
  inline GameExitReq() : GameExitReq(nullptr) {}
  ~GameExitReq() override;
  explicit constexpr GameExitReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameExitReq(const GameExitReq& from);
  GameExitReq(GameExitReq&& from) noexcept
    : GameExitReq() {
    *this = ::std::move(from);
  }

  inline GameExitReq& operator=(const GameExitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameExitReq& operator=(GameExitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameExitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameExitReq* internal_default_instance() {
    return reinterpret_cast<const GameExitReq*>(
               &_GameExitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GameExitReq& a, GameExitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GameExitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameExitReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameExitReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameExitReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameExitReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameExitReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameExitReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameExitReq";
  }
  protected:
  explicit GameExitReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .XTankMsg.PlayerId playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const ::XTankMsg::PlayerId& playerid() const;
  PROTOBUF_NODISCARD ::XTankMsg::PlayerId* release_playerid();
  ::XTankMsg::PlayerId* mutable_playerid();
  void set_allocated_playerid(::XTankMsg::PlayerId* playerid);
  private:
  const ::XTankMsg::PlayerId& _internal_playerid() const;
  ::XTankMsg::PlayerId* _internal_mutable_playerid();
  public:
  void unsafe_arena_set_allocated_playerid(
      ::XTankMsg::PlayerId* playerid);
  ::XTankMsg::PlayerId* unsafe_arena_release_playerid();

  // @@protoc_insertion_point(class_scope:XTankMsg.GameExitReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XTankMsg::PlayerId* playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// -------------------------------------------------------------------

class GameExitAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XTankMsg.GameExitAck) */ {
 public:
  inline GameExitAck() : GameExitAck(nullptr) {}
  ~GameExitAck() override;
  explicit constexpr GameExitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameExitAck(const GameExitAck& from);
  GameExitAck(GameExitAck&& from) noexcept
    : GameExitAck() {
    *this = ::std::move(from);
  }

  inline GameExitAck& operator=(const GameExitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameExitAck& operator=(GameExitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameExitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameExitAck* internal_default_instance() {
    return reinterpret_cast<const GameExitAck*>(
               &_GameExitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GameExitAck& a, GameExitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GameExitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameExitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameExitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameExitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameExitAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameExitAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameExitAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XTankMsg.GameExitAck";
  }
  protected:
  explicit GameExitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XTankMsg.GameExitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_XTankMsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerId

// string ip = 1;
inline void PlayerId::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& PlayerId::ip() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerId.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerId::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerId.ip)
}
inline std::string* PlayerId::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:XTankMsg.PlayerId.ip)
  return _s;
}
inline const std::string& PlayerId::_internal_ip() const {
  return ip_.Get();
}
inline void PlayerId::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerId::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerId::release_ip() {
  // @@protoc_insertion_point(field_release:XTankMsg.PlayerId.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerId::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.PlayerId.ip)
}

// uint64 pid = 2;
inline void PlayerId::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t PlayerId::_internal_pid() const {
  return pid_;
}
inline uint64_t PlayerId::pid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.PlayerId.pid)
  return _internal_pid();
}
inline void PlayerId::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void PlayerId::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.PlayerId.pid)
}

// -------------------------------------------------------------------

// LoginReq

// .XTankMsg.PlayerId playerId = 1;
inline bool LoginReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool LoginReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void LoginReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& LoginReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& LoginReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LoginReq.playerId)
  return _internal_playerid();
}
inline void LoginReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.LoginReq.playerId)
}
inline ::XTankMsg::PlayerId* LoginReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* LoginReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.LoginReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* LoginReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* LoginReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LoginReq.playerId)
  return _msg;
}
inline void LoginReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LoginReq.playerId)
}

// -------------------------------------------------------------------

// LoginAck

// bool success = 1;
inline void LoginAck::clear_success() {
  success_ = false;
}
inline bool LoginAck::_internal_success() const {
  return success_;
}
inline bool LoginAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LoginAck.success)
  return _internal_success();
}
inline void LoginAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void LoginAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LoginAck.success)
}

// string msg = 2;
inline void LoginAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& LoginAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LoginAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.LoginAck.msg)
}
inline std::string* LoginAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LoginAck.msg)
  return _s;
}
inline const std::string& LoginAck::_internal_msg() const {
  return msg_.Get();
}
inline void LoginAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.LoginAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LoginAck.msg)
}

// -------------------------------------------------------------------

// LogoutReq

// .XTankMsg.PlayerId playerId = 1;
inline bool LogoutReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool LogoutReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void LogoutReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& LogoutReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& LogoutReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LogoutReq.playerId)
  return _internal_playerid();
}
inline void LogoutReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.LogoutReq.playerId)
}
inline ::XTankMsg::PlayerId* LogoutReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* LogoutReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.LogoutReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* LogoutReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* LogoutReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LogoutReq.playerId)
  return _msg;
}
inline void LogoutReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LogoutReq.playerId)
}

// -------------------------------------------------------------------

// LogoutAck

// bool success = 1;
inline void LogoutAck::clear_success() {
  success_ = false;
}
inline bool LogoutAck::_internal_success() const {
  return success_;
}
inline bool LogoutAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LogoutAck.success)
  return _internal_success();
}
inline void LogoutAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void LogoutAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LogoutAck.success)
}

// string msg = 2;
inline void LogoutAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& LogoutAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LogoutAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.LogoutAck.msg)
}
inline std::string* LogoutAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.LogoutAck.msg)
  return _s;
}
inline const std::string& LogoutAck::_internal_msg() const {
  return msg_.Get();
}
inline void LogoutAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogoutAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogoutAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.LogoutAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LogoutAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.LogoutAck.msg)
}

// -------------------------------------------------------------------

// LobbyNtf_RoomInfo

// uint32 id = 1;
inline void LobbyNtf_RoomInfo::clear_id() {
  id_ = 0u;
}
inline uint32_t LobbyNtf_RoomInfo::_internal_id() const {
  return id_;
}
inline uint32_t LobbyNtf_RoomInfo::id() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.RoomInfo.id)
  return _internal_id();
}
inline void LobbyNtf_RoomInfo::_internal_set_id(uint32_t value) {
  
  id_ = value;
}
inline void LobbyNtf_RoomInfo::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LobbyNtf.RoomInfo.id)
}

// uint32 playerNum = 2;
inline void LobbyNtf_RoomInfo::clear_playernum() {
  playernum_ = 0u;
}
inline uint32_t LobbyNtf_RoomInfo::_internal_playernum() const {
  return playernum_;
}
inline uint32_t LobbyNtf_RoomInfo::playernum() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.RoomInfo.playerNum)
  return _internal_playernum();
}
inline void LobbyNtf_RoomInfo::_internal_set_playernum(uint32_t value) {
  
  playernum_ = value;
}
inline void LobbyNtf_RoomInfo::set_playernum(uint32_t value) {
  _internal_set_playernum(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LobbyNtf.RoomInfo.playerNum)
}

// bool inGame = 3;
inline void LobbyNtf_RoomInfo::clear_ingame() {
  ingame_ = false;
}
inline bool LobbyNtf_RoomInfo::_internal_ingame() const {
  return ingame_;
}
inline bool LobbyNtf_RoomInfo::ingame() const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.RoomInfo.inGame)
  return _internal_ingame();
}
inline void LobbyNtf_RoomInfo::_internal_set_ingame(bool value) {
  
  ingame_ = value;
}
inline void LobbyNtf_RoomInfo::set_ingame(bool value) {
  _internal_set_ingame(value);
  // @@protoc_insertion_point(field_set:XTankMsg.LobbyNtf.RoomInfo.inGame)
}

// -------------------------------------------------------------------

// LobbyNtf

// repeated .XTankMsg.LobbyNtf.RoomInfo rooms = 1;
inline int LobbyNtf::_internal_rooms_size() const {
  return rooms_.size();
}
inline int LobbyNtf::rooms_size() const {
  return _internal_rooms_size();
}
inline void LobbyNtf::clear_rooms() {
  rooms_.Clear();
}
inline ::XTankMsg::LobbyNtf_RoomInfo* LobbyNtf::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.LobbyNtf.rooms)
  return rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >*
LobbyNtf::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.LobbyNtf.rooms)
  return &rooms_;
}
inline const ::XTankMsg::LobbyNtf_RoomInfo& LobbyNtf::_internal_rooms(int index) const {
  return rooms_.Get(index);
}
inline const ::XTankMsg::LobbyNtf_RoomInfo& LobbyNtf::rooms(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.LobbyNtf.rooms)
  return _internal_rooms(index);
}
inline ::XTankMsg::LobbyNtf_RoomInfo* LobbyNtf::_internal_add_rooms() {
  return rooms_.Add();
}
inline ::XTankMsg::LobbyNtf_RoomInfo* LobbyNtf::add_rooms() {
  ::XTankMsg::LobbyNtf_RoomInfo* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:XTankMsg.LobbyNtf.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::LobbyNtf_RoomInfo >&
LobbyNtf::rooms() const {
  // @@protoc_insertion_point(field_list:XTankMsg.LobbyNtf.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// RoomCreateReq

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomCreateReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomCreateReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomCreateReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomCreateReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomCreateReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomCreateReq.playerId)
  return _internal_playerid();
}
inline void RoomCreateReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomCreateReq.playerId)
}
inline ::XTankMsg::PlayerId* RoomCreateReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomCreateReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomCreateReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomCreateReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomCreateReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomCreateReq.playerId)
  return _msg;
}
inline void RoomCreateReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomCreateReq.playerId)
}

// -------------------------------------------------------------------

// RoomCreateAck

// bool success = 1;
inline void RoomCreateAck::clear_success() {
  success_ = false;
}
inline bool RoomCreateAck::_internal_success() const {
  return success_;
}
inline bool RoomCreateAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomCreateAck.success)
  return _internal_success();
}
inline void RoomCreateAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RoomCreateAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomCreateAck.success)
}

// string msg = 2;
inline void RoomCreateAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& RoomCreateAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomCreateAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomCreateAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.RoomCreateAck.msg)
}
inline std::string* RoomCreateAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomCreateAck.msg)
  return _s;
}
inline const std::string& RoomCreateAck::_internal_msg() const {
  return msg_.Get();
}
inline void RoomCreateAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomCreateAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomCreateAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomCreateAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomCreateAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomCreateAck.msg)
}

// -------------------------------------------------------------------

// RoomJoinReq

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomJoinReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomJoinReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomJoinReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomJoinReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomJoinReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinReq.playerId)
  return _internal_playerid();
}
inline void RoomJoinReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomJoinReq.playerId)
}
inline ::XTankMsg::PlayerId* RoomJoinReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomJoinReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomJoinReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomJoinReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomJoinReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomJoinReq.playerId)
  return _msg;
}
inline void RoomJoinReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomJoinReq.playerId)
}

// uint64 roomId = 2;
inline void RoomJoinReq::clear_roomid() {
  roomid_ = uint64_t{0u};
}
inline uint64_t RoomJoinReq::_internal_roomid() const {
  return roomid_;
}
inline uint64_t RoomJoinReq::roomid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinReq.roomId)
  return _internal_roomid();
}
inline void RoomJoinReq::_internal_set_roomid(uint64_t value) {
  
  roomid_ = value;
}
inline void RoomJoinReq::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomJoinReq.roomId)
}

// -------------------------------------------------------------------

// RoomJoinAck

// bool success = 1;
inline void RoomJoinAck::clear_success() {
  success_ = false;
}
inline bool RoomJoinAck::_internal_success() const {
  return success_;
}
inline bool RoomJoinAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinAck.success)
  return _internal_success();
}
inline void RoomJoinAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RoomJoinAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomJoinAck.success)
}

// string msg = 2;
inline void RoomJoinAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& RoomJoinAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomJoinAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomJoinAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.RoomJoinAck.msg)
}
inline std::string* RoomJoinAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomJoinAck.msg)
  return _s;
}
inline const std::string& RoomJoinAck::_internal_msg() const {
  return msg_.Get();
}
inline void RoomJoinAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomJoinAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomJoinAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomJoinAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomJoinAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomJoinAck.msg)
}

// -------------------------------------------------------------------

// RoomExitReq

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomExitReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomExitReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomExitReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomExitReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomExitReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomExitReq.playerId)
  return _internal_playerid();
}
inline void RoomExitReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomExitReq.playerId)
}
inline ::XTankMsg::PlayerId* RoomExitReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomExitReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomExitReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomExitReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomExitReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomExitReq.playerId)
  return _msg;
}
inline void RoomExitReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomExitReq.playerId)
}

// -------------------------------------------------------------------

// RoomExitAck

// bool success = 1;
inline void RoomExitAck::clear_success() {
  success_ = false;
}
inline bool RoomExitAck::_internal_success() const {
  return success_;
}
inline bool RoomExitAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomExitAck.success)
  return _internal_success();
}
inline void RoomExitAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RoomExitAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomExitAck.success)
}

// string msg = 2;
inline void RoomExitAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& RoomExitAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomExitAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomExitAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.RoomExitAck.msg)
}
inline std::string* RoomExitAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomExitAck.msg)
  return _s;
}
inline const std::string& RoomExitAck::_internal_msg() const {
  return msg_.Get();
}
inline void RoomExitAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomExitAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomExitAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomExitAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomExitAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomExitAck.msg)
}

// -------------------------------------------------------------------

// RoomNtf_PlayerState

// .XTankMsg.PlayerId playerId = 1;
inline bool RoomNtf_PlayerState::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool RoomNtf_PlayerState::has_playerid() const {
  return _internal_has_playerid();
}
inline void RoomNtf_PlayerState::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& RoomNtf_PlayerState::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& RoomNtf_PlayerState::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.PlayerState.playerId)
  return _internal_playerid();
}
inline void RoomNtf_PlayerState::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.RoomNtf.PlayerState.playerId)
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.RoomNtf.PlayerState.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* RoomNtf_PlayerState::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomNtf.PlayerState.playerId)
  return _msg;
}
inline void RoomNtf_PlayerState::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.RoomNtf.PlayerState.playerId)
}

// bool ready = 2;
inline void RoomNtf_PlayerState::clear_ready() {
  ready_ = false;
}
inline bool RoomNtf_PlayerState::_internal_ready() const {
  return ready_;
}
inline bool RoomNtf_PlayerState::ready() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.PlayerState.ready)
  return _internal_ready();
}
inline void RoomNtf_PlayerState::_internal_set_ready(bool value) {
  
  ready_ = value;
}
inline void RoomNtf_PlayerState::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomNtf.PlayerState.ready)
}

// -------------------------------------------------------------------

// RoomNtf

// uint32 roomId = 1;
inline void RoomNtf::clear_roomid() {
  roomid_ = 0u;
}
inline uint32_t RoomNtf::_internal_roomid() const {
  return roomid_;
}
inline uint32_t RoomNtf::roomid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.roomId)
  return _internal_roomid();
}
inline void RoomNtf::_internal_set_roomid(uint32_t value) {
  
  roomid_ = value;
}
inline void RoomNtf::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.RoomNtf.roomId)
}

// repeated .XTankMsg.RoomNtf.PlayerState playerStates = 2;
inline int RoomNtf::_internal_playerstates_size() const {
  return playerstates_.size();
}
inline int RoomNtf::playerstates_size() const {
  return _internal_playerstates_size();
}
inline void RoomNtf::clear_playerstates() {
  playerstates_.Clear();
}
inline ::XTankMsg::RoomNtf_PlayerState* RoomNtf::mutable_playerstates(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.RoomNtf.playerStates)
  return playerstates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >*
RoomNtf::mutable_playerstates() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.RoomNtf.playerStates)
  return &playerstates_;
}
inline const ::XTankMsg::RoomNtf_PlayerState& RoomNtf::_internal_playerstates(int index) const {
  return playerstates_.Get(index);
}
inline const ::XTankMsg::RoomNtf_PlayerState& RoomNtf::playerstates(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.RoomNtf.playerStates)
  return _internal_playerstates(index);
}
inline ::XTankMsg::RoomNtf_PlayerState* RoomNtf::_internal_add_playerstates() {
  return playerstates_.Add();
}
inline ::XTankMsg::RoomNtf_PlayerState* RoomNtf::add_playerstates() {
  ::XTankMsg::RoomNtf_PlayerState* _add = _internal_add_playerstates();
  // @@protoc_insertion_point(field_add:XTankMsg.RoomNtf.playerStates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::RoomNtf_PlayerState >&
RoomNtf::playerstates() const {
  // @@protoc_insertion_point(field_list:XTankMsg.RoomNtf.playerStates)
  return playerstates_;
}

// -------------------------------------------------------------------

// GameReadyReq

// .XTankMsg.PlayerId playerId = 1;
inline bool GameReadyReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool GameReadyReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameReadyReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& GameReadyReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& GameReadyReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyReq.playerId)
  return _internal_playerid();
}
inline void GameReadyReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.GameReadyReq.playerId)
}
inline ::XTankMsg::PlayerId* GameReadyReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* GameReadyReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameReadyReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* GameReadyReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* GameReadyReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameReadyReq.playerId)
  return _msg;
}
inline void GameReadyReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameReadyReq.playerId)
}

// -------------------------------------------------------------------

// GameReadyAck

// bool success = 1;
inline void GameReadyAck::clear_success() {
  success_ = false;
}
inline bool GameReadyAck::_internal_success() const {
  return success_;
}
inline bool GameReadyAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyAck.success)
  return _internal_success();
}
inline void GameReadyAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GameReadyAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameReadyAck.success)
}

// string msg = 2;
inline void GameReadyAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& GameReadyAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameReadyAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.GameReadyAck.msg)
}
inline std::string* GameReadyAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameReadyAck.msg)
  return _s;
}
inline const std::string& GameReadyAck::_internal_msg() const {
  return msg_.Get();
}
inline void GameReadyAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameReadyAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameReadyAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameReadyAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameReadyAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameReadyAck.msg)
}

// -------------------------------------------------------------------

// GameReadyCancelReq

// .XTankMsg.PlayerId playerId = 1;
inline bool GameReadyCancelReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool GameReadyCancelReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameReadyCancelReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& GameReadyCancelReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& GameReadyCancelReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyCancelReq.playerId)
  return _internal_playerid();
}
inline void GameReadyCancelReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.GameReadyCancelReq.playerId)
}
inline ::XTankMsg::PlayerId* GameReadyCancelReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* GameReadyCancelReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameReadyCancelReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* GameReadyCancelReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* GameReadyCancelReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameReadyCancelReq.playerId)
  return _msg;
}
inline void GameReadyCancelReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameReadyCancelReq.playerId)
}

// -------------------------------------------------------------------

// GameReadyCancelAck

// bool success = 1;
inline void GameReadyCancelAck::clear_success() {
  success_ = false;
}
inline bool GameReadyCancelAck::_internal_success() const {
  return success_;
}
inline bool GameReadyCancelAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyCancelAck.success)
  return _internal_success();
}
inline void GameReadyCancelAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GameReadyCancelAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameReadyCancelAck.success)
}

// string msg = 2;
inline void GameReadyCancelAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& GameReadyCancelAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyCancelAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameReadyCancelAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.GameReadyCancelAck.msg)
}
inline std::string* GameReadyCancelAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameReadyCancelAck.msg)
  return _s;
}
inline const std::string& GameReadyCancelAck::_internal_msg() const {
  return msg_.Get();
}
inline void GameReadyCancelAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameReadyCancelAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameReadyCancelAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameReadyCancelAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameReadyCancelAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameReadyCancelAck.msg)
}

// -------------------------------------------------------------------

// GameReadyNtf

// bool success = 1;
inline void GameReadyNtf::clear_success() {
  success_ = false;
}
inline bool GameReadyNtf::_internal_success() const {
  return success_;
}
inline bool GameReadyNtf::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyNtf.success)
  return _internal_success();
}
inline void GameReadyNtf::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GameReadyNtf::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameReadyNtf.success)
}

// string msg = 2;
inline void GameReadyNtf::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& GameReadyNtf::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameReadyNtf.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameReadyNtf::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.GameReadyNtf.msg)
}
inline std::string* GameReadyNtf::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameReadyNtf.msg)
  return _s;
}
inline const std::string& GameReadyNtf::_internal_msg() const {
  return msg_.Get();
}
inline void GameReadyNtf::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameReadyNtf::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameReadyNtf::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameReadyNtf.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameReadyNtf::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameReadyNtf.msg)
}

// -------------------------------------------------------------------

// GameStartNtf

// float latency = 1;
inline void GameStartNtf::clear_latency() {
  latency_ = 0;
}
inline float GameStartNtf::_internal_latency() const {
  return latency_;
}
inline float GameStartNtf::latency() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameStartNtf.latency)
  return _internal_latency();
}
inline void GameStartNtf::_internal_set_latency(float value) {
  
  latency_ = value;
}
inline void GameStartNtf::set_latency(float value) {
  _internal_set_latency(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameStartNtf.latency)
}

// repeated .XTankMsg.PlayerId playerIds = 2;
inline int GameStartNtf::_internal_playerids_size() const {
  return playerids_.size();
}
inline int GameStartNtf::playerids_size() const {
  return _internal_playerids_size();
}
inline void GameStartNtf::clear_playerids() {
  playerids_.Clear();
}
inline ::XTankMsg::PlayerId* GameStartNtf::mutable_playerids(int index) {
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameStartNtf.playerIds)
  return playerids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >*
GameStartNtf::mutable_playerids() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.GameStartNtf.playerIds)
  return &playerids_;
}
inline const ::XTankMsg::PlayerId& GameStartNtf::_internal_playerids(int index) const {
  return playerids_.Get(index);
}
inline const ::XTankMsg::PlayerId& GameStartNtf::playerids(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameStartNtf.playerIds)
  return _internal_playerids(index);
}
inline ::XTankMsg::PlayerId* GameStartNtf::_internal_add_playerids() {
  return playerids_.Add();
}
inline ::XTankMsg::PlayerId* GameStartNtf::add_playerids() {
  ::XTankMsg::PlayerId* _add = _internal_add_playerids();
  // @@protoc_insertion_point(field_add:XTankMsg.GameStartNtf.playerIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::XTankMsg::PlayerId >&
GameStartNtf::playerids() const {
  // @@protoc_insertion_point(field_list:XTankMsg.GameStartNtf.playerIds)
  return playerids_;
}

// -------------------------------------------------------------------

// GameInputNtf

// .XTankMsg.PlayerId playerId = 1;
inline bool GameInputNtf::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool GameInputNtf::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameInputNtf::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& GameInputNtf::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& GameInputNtf::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameInputNtf.playerId)
  return _internal_playerid();
}
inline void GameInputNtf::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.GameInputNtf.playerId)
}
inline ::XTankMsg::PlayerId* GameInputNtf::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* GameInputNtf::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameInputNtf.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* GameInputNtf::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* GameInputNtf::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameInputNtf.playerId)
  return _msg;
}
inline void GameInputNtf::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameInputNtf.playerId)
}

// uint32 frameId = 2;
inline void GameInputNtf::clear_frameid() {
  frameid_ = 0u;
}
inline uint32_t GameInputNtf::_internal_frameid() const {
  return frameid_;
}
inline uint32_t GameInputNtf::frameid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameInputNtf.frameId)
  return _internal_frameid();
}
inline void GameInputNtf::_internal_set_frameid(uint32_t value) {
  
  frameid_ = value;
}
inline void GameInputNtf::set_frameid(uint32_t value) {
  _internal_set_frameid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameInputNtf.frameId)
}

// uint32 playerCmd = 3;
inline void GameInputNtf::clear_playercmd() {
  playercmd_ = 0u;
}
inline uint32_t GameInputNtf::_internal_playercmd() const {
  return playercmd_;
}
inline uint32_t GameInputNtf::playercmd() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameInputNtf.playerCmd)
  return _internal_playercmd();
}
inline void GameInputNtf::_internal_set_playercmd(uint32_t value) {
  
  playercmd_ = value;
}
inline void GameInputNtf::set_playercmd(uint32_t value) {
  _internal_set_playercmd(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameInputNtf.playerCmd)
}

// -------------------------------------------------------------------

// GameForwardNtf

// uint32 frameId = 1;
inline void GameForwardNtf::clear_frameid() {
  frameid_ = 0u;
}
inline uint32_t GameForwardNtf::_internal_frameid() const {
  return frameid_;
}
inline uint32_t GameForwardNtf::frameid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameForwardNtf.frameId)
  return _internal_frameid();
}
inline void GameForwardNtf::_internal_set_frameid(uint32_t value) {
  
  frameid_ = value;
}
inline void GameForwardNtf::set_frameid(uint32_t value) {
  _internal_set_frameid(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameForwardNtf.frameId)
}

// repeated uint32 playerCmds = 2;
inline int GameForwardNtf::_internal_playercmds_size() const {
  return playercmds_.size();
}
inline int GameForwardNtf::playercmds_size() const {
  return _internal_playercmds_size();
}
inline void GameForwardNtf::clear_playercmds() {
  playercmds_.Clear();
}
inline uint32_t GameForwardNtf::_internal_playercmds(int index) const {
  return playercmds_.Get(index);
}
inline uint32_t GameForwardNtf::playercmds(int index) const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameForwardNtf.playerCmds)
  return _internal_playercmds(index);
}
inline void GameForwardNtf::set_playercmds(int index, uint32_t value) {
  playercmds_.Set(index, value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameForwardNtf.playerCmds)
}
inline void GameForwardNtf::_internal_add_playercmds(uint32_t value) {
  playercmds_.Add(value);
}
inline void GameForwardNtf::add_playercmds(uint32_t value) {
  _internal_add_playercmds(value);
  // @@protoc_insertion_point(field_add:XTankMsg.GameForwardNtf.playerCmds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameForwardNtf::_internal_playercmds() const {
  return playercmds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GameForwardNtf::playercmds() const {
  // @@protoc_insertion_point(field_list:XTankMsg.GameForwardNtf.playerCmds)
  return _internal_playercmds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameForwardNtf::_internal_mutable_playercmds() {
  return &playercmds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GameForwardNtf::mutable_playercmds() {
  // @@protoc_insertion_point(field_mutable_list:XTankMsg.GameForwardNtf.playerCmds)
  return _internal_mutable_playercmds();
}

// -------------------------------------------------------------------

// GameExitReq

// .XTankMsg.PlayerId playerId = 1;
inline bool GameExitReq::_internal_has_playerid() const {
  return this != internal_default_instance() && playerid_ != nullptr;
}
inline bool GameExitReq::has_playerid() const {
  return _internal_has_playerid();
}
inline void GameExitReq::clear_playerid() {
  if (GetArenaForAllocation() == nullptr && playerid_ != nullptr) {
    delete playerid_;
  }
  playerid_ = nullptr;
}
inline const ::XTankMsg::PlayerId& GameExitReq::_internal_playerid() const {
  const ::XTankMsg::PlayerId* p = playerid_;
  return p != nullptr ? *p : reinterpret_cast<const ::XTankMsg::PlayerId&>(
      ::XTankMsg::_PlayerId_default_instance_);
}
inline const ::XTankMsg::PlayerId& GameExitReq::playerid() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameExitReq.playerId)
  return _internal_playerid();
}
inline void GameExitReq::unsafe_arena_set_allocated_playerid(
    ::XTankMsg::PlayerId* playerid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerid_);
  }
  playerid_ = playerid;
  if (playerid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XTankMsg.GameExitReq.playerId)
}
inline ::XTankMsg::PlayerId* GameExitReq::release_playerid() {
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XTankMsg::PlayerId* GameExitReq::unsafe_arena_release_playerid() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameExitReq.playerId)
  
  ::XTankMsg::PlayerId* temp = playerid_;
  playerid_ = nullptr;
  return temp;
}
inline ::XTankMsg::PlayerId* GameExitReq::_internal_mutable_playerid() {
  
  if (playerid_ == nullptr) {
    auto* p = CreateMaybeMessage<::XTankMsg::PlayerId>(GetArenaForAllocation());
    playerid_ = p;
  }
  return playerid_;
}
inline ::XTankMsg::PlayerId* GameExitReq::mutable_playerid() {
  ::XTankMsg::PlayerId* _msg = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameExitReq.playerId)
  return _msg;
}
inline void GameExitReq::set_allocated_playerid(::XTankMsg::PlayerId* playerid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerid_;
  }
  if (playerid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XTankMsg::PlayerId>::GetOwningArena(playerid);
    if (message_arena != submessage_arena) {
      playerid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerid, submessage_arena);
    }
    
  } else {
    
  }
  playerid_ = playerid;
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameExitReq.playerId)
}

// -------------------------------------------------------------------

// GameExitAck

// bool success = 1;
inline void GameExitAck::clear_success() {
  success_ = false;
}
inline bool GameExitAck::_internal_success() const {
  return success_;
}
inline bool GameExitAck::success() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameExitAck.success)
  return _internal_success();
}
inline void GameExitAck::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GameExitAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:XTankMsg.GameExitAck.success)
}

// string msg = 2;
inline void GameExitAck::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& GameExitAck::msg() const {
  // @@protoc_insertion_point(field_get:XTankMsg.GameExitAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameExitAck::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XTankMsg.GameExitAck.msg)
}
inline std::string* GameExitAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XTankMsg.GameExitAck.msg)
  return _s;
}
inline const std::string& GameExitAck::_internal_msg() const {
  return msg_.Get();
}
inline void GameExitAck::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameExitAck::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameExitAck::release_msg() {
  // @@protoc_insertion_point(field_release:XTankMsg.GameExitAck.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameExitAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XTankMsg.GameExitAck.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace XTankMsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::XTankMsg::MSG> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XTankMsg::MSG>() {
  return ::XTankMsg::MSG_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_XTankMsg_2eproto
